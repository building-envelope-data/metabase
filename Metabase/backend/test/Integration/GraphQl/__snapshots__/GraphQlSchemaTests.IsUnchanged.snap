schema {
  query: Query
  mutation: Mutation
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

interface Reference {
  abstract: String
  section: String
  title: String
}

interface Stakeholder {
  name: String!
}

type AddInstitutionRepresentativeError {
  code: AddInstitutionRepresentativeErrorCode!
  message: String!
  path: [String!]!
}

type AddInstitutionRepresentativePayload {
  errors: [AddInstitutionRepresentativeError!]
  institutionRepresentativeEdge: InstitutionRepresentativeEdge
  representedInstitutionEdge: RepresentedInstitutionEdge
}

type ChangeInstitutionRepresentativeRoleError {
  code: ChangeInstitutionRepresentativeRoleErrorCode!
  message: String!
  path: [String!]!
}

type ChangeInstitutionRepresentativeRolePayload {
  errors: [ChangeInstitutionRepresentativeRoleError!]
  institutionRepresentativeEdge: InstitutionRepresentativeEdge
  representedInstitutionEdge: RepresentedInstitutionEdge
}

type ChangeUserEmailError {
  code: ChangeUserEmailErrorCode!
  message: String!
  path: [String!]!
}

type ChangeUserEmailPayload {
  errors: [ChangeUserEmailError!]
  user: User
}

type ChangeUserPasswordError {
  code: ChangeUserPasswordErrorCode!
  message: String!
  path: [String!]!
}

type ChangeUserPasswordPayload {
  errors: [ChangeUserPasswordError!]
  user: User
}

type Component implements Node {
  abbreviation: String
  availability: OpenEndedDateTimeRange
  categories: [ComponentCategory!]!
  description: String!
  id: ID!
  manufacturers: ComponentManufacturerConnection!
  name: String!
  uuid: Uuid!
}

"A connection to a list of items."
type ComponentConnection {
  "A list of edges."
  edges: [ComponentEdge!]
  "A flattened list of the nodes."
  nodes: [Component!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

"An edge in a connection."
type ComponentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Component!
}

type ComponentManufacturerConnection {
  edges: [ComponentManufacturerEdge!]!
}

type ComponentManufacturerEdge {
  node: Institution!
}

type ConfirmUserEmailChangeError {
  code: ConfirmUserEmailChangeErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmUserEmailChangePayload {
  errors: [ConfirmUserEmailChangeError!]
  user: User
}

type ConfirmUserEmailError {
  code: ConfirmUserEmailErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmUserEmailPayload {
  errors: [ConfirmUserEmailError!]
  user: User
}

type CreateComponentError {
  code: CreateComponentErrorCode!
  message: String!
  path: [String!]!
}

type CreateComponentPayload {
  component: Component
  errors: [CreateComponentError!]
}

type CreateDataFormatError {
  code: CreateDataFormatErrorCode!
  message: String!
  path: [String!]!
}

type CreateDataFormatPayload {
  dataFormat: DataFormat
  errors: [CreateDataFormatError!]
}

type CreateDatabaseError {
  code: CreateDatabaseErrorCode!
  message: String!
  path: [String!]!
}

type CreateDatabasePayload {
  database: Database
  errors: [CreateDatabaseError!]
}

type CreateInstitutionError {
  code: CreateInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type CreateInstitutionPayload {
  errors: [CreateInstitutionError!]
  institution: Institution
}

type CreateMethodError {
  code: CreateMethodErrorCode!
  message: String!
  path: [String!]!
}

type CreateMethodPayload {
  errors: [CreateMethodError!]
  method: Method
}

type DataFormat implements Node {
  description: String!
  extension: String
  id: ID!
  manager: DataFormatManagerEdge!
  mediaType: String!
  name: String!
  reference: Reference
  schemaLocator: Url
  uuid: Uuid!
}

"A connection to a list of items."
type DataFormatConnection {
  "A list of edges."
  edges: [DataFormatEdge!]
  "A flattened list of the nodes."
  nodes: [DataFormat!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

"An edge in a connection."
type DataFormatEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DataFormat!
}

type DataFormatManagerEdge {
  node: Institution!
}

type Database implements Node {
  description: String!
  id: ID!
  locator: Url!
  name: String!
  operator: DatabaseOperatorEdge!
  uuid: Uuid!
}

"A connection to a list of items."
type DatabaseConnection {
  "A list of edges."
  edges: [DatabaseEdge!]
  "A flattened list of the nodes."
  nodes: [Database!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

"An edge in a connection."
type DatabaseEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Database!
}

type DatabaseOperatorEdge {
  node: Institution!
}

type DeleteInstitutionError {
  code: DeleteInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type DeleteInstitutionPayload {
  errors: [DeleteInstitutionError!]
}

type DeletePersonalUserDataError {
  code: DeletePersonalUserDataErrorCode!
  message: String!
  path: [String!]!
}

type DeletePersonalUserDataPayload {
  errors: [DeletePersonalUserDataError!]
  user: User
}

type GenerateUserTwoFactorRecoveryCodesError {
  code: GenerateUserTwoFactorRecoveryCodesErrorCode!
  message: String!
  path: [String!]!
}

type GenerateUserTwoFactorRecoveryCodesPayload {
  errors: [GenerateUserTwoFactorRecoveryCodesError!]
  twoFactorRecoveryCodes: [String!]
  user: User
}

type Institution implements Node & Stakeholder {
  abbreviation: String
  description: String!
  developedMethods: InstitutionDevelopedMethodConnection!
  id: ID!
  managedDataFormats: InstitutionManagedDataFormatConnection!
  manufacturedComponents: InstitutionManufacturedComponentConnection!
  name: String!
  operatedDatabases: InstitutionOperatedDatabaseConnection!
  publicKey: String
  representatives: InstitutionRepresentativeConnection!
  state: InstitutionState!
  uuid: Uuid!
  websiteLocator: Url
}

"A connection to a list of items."
type InstitutionConnection {
  "A list of edges."
  edges: [InstitutionEdge!]
  "A flattened list of the nodes."
  nodes: [Institution]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

type InstitutionDevelopedMethodConnection {
  edges: [InstitutionDevelopedMethodEdge!]!
}

type InstitutionDevelopedMethodEdge {
  node: Method!
}

"An edge in a connection."
type InstitutionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Institution
}

type InstitutionManagedDataFormatConnection {
  edges: [InstitutionManagedDataFormatEdge!]!
}

type InstitutionManagedDataFormatEdge {
  node: DataFormat!
}

type InstitutionManufacturedComponentConnection {
  edges: [InstitutionManufacturedComponentEdge!]!
}

type InstitutionManufacturedComponentEdge {
  node: Component!
}

type InstitutionOperatedDatabaseConnection {
  edges: [InstitutionOperatedDatabaseEdge!]!
}

type InstitutionOperatedDatabaseEdge {
  node: Database!
}

type InstitutionRepresentativeConnection {
  edges: [InstitutionRepresentativeEdge!]!
}

type InstitutionRepresentativeEdge {
  node: User!
  role: InstitutionRepresentativeRole!
}

type LoginUserError {
  code: LoginUserErrorCode!
  message: String!
  path: [String!]!
}

type LoginUserPayload {
  errors: [LoginUserError!]
  requiresTwoFactor: Boolean
  user: User
}

type LogoutUserError {
  code: LogoutUserErrorCode!
  message: String!
  path: [String!]!
}

type LogoutUserPayload {
  errors: [LogoutUserError!]
  user: User
}

type Method implements Node {
  availability: OpenEndedDateTimeRange
  calculationLocator: Url
  categories: [MethodCategory!]!
  description: String!
  developers: MethodDeveloperConnection!
  id: ID!
  name: String!
  reference: Reference
  uuid: Uuid!
  validity: OpenEndedDateTimeRange
}

"A connection to a list of items."
type MethodConnection {
  "A list of edges."
  edges: [MethodEdge!]
  "A flattened list of the nodes."
  nodes: [Method!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

type MethodDeveloperConnection {
  edges: [MethodDeveloperEdge!]!
}

type MethodDeveloperEdge {
  node: Stakeholder!
}

"An edge in a connection."
type MethodEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Method!
}

type Mutation {
  addInstitutionRepresentative(input: AddInstitutionRepresentativeInput!): AddInstitutionRepresentativePayload! @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  changeInstitutionRepresentativeRole(input: ChangeInstitutionRepresentativeRoleInput!): ChangeInstitutionRepresentativeRolePayload! @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  changeUserEmail(input: ChangeUserEmailInput!): ChangeUserEmailPayload! @authorize(apply: BEFORE_RESOLVER)
  changeUserPassword(input: ChangeUserPasswordInput!): ChangeUserPasswordPayload! @authorize(apply: BEFORE_RESOLVER)
  confirmUserEmail(input: ConfirmUserEmailInput!): ConfirmUserEmailPayload!
  confirmUserEmailChange(input: ConfirmUserEmailChangeInput!): ConfirmUserEmailChangePayload!
  createComponent(input: CreateComponentInput!): CreateComponentPayload! @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  createDatabase(input: CreateDatabaseInput!): CreateDatabasePayload! @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  createDataFormat(input: CreateDataFormatInput!): CreateDataFormatPayload! @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  createInstitution(input: CreateInstitutionInput!): CreateInstitutionPayload! @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  createMethod(input: CreateMethodInput!): CreateMethodPayload! @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  deleteInstitution(input: DeleteInstitutionInput!): DeleteInstitutionPayload! @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  deletePersonalUserData(input: DeletePersonalUserDataInput!): DeletePersonalUserDataPayload! @authorize(apply: BEFORE_RESOLVER)
  generateUserTwoFactorRecoveryCodes: GenerateUserTwoFactorRecoveryCodesPayload! @authorize(apply: BEFORE_RESOLVER)
  loginUser(input: LoginUserInput!): LoginUserPayload!
  logoutUser: LogoutUserPayload!
  registerUser(input: RegisterUserInput!): RegisterUserPayload!
  removeInstitutionRepresentative(input: RemoveInstitutionRepresentativeInput!): RemoveInstitutionRepresentativePayload! @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  requestUserPasswordReset(input: RequestUserPasswordResetInput!): RequestUserPasswordResetPayload!
  resendUserEmailConfirmation(input: ResendUserEmailConfirmationInput!): ResendUserEmailConfirmationPayload!
  resendUserEmailVerification: ResendUserEmailVerificationPayload! @authorize(apply: BEFORE_RESOLVER)
  resetUserPassword(input: ResetUserPasswordInput!): ResetUserPasswordPayload!
  setUserPassword(input: SetUserPasswordInput!): SetUserPasswordPayload! @authorize(apply: BEFORE_RESOLVER)
  setUserPhoneNumber(input: SetUserPhoneNumberInput!): SetUserPhoneNumberPayload! @authorize(apply: BEFORE_RESOLVER)
  updateInstitution(input: UpdateInstitutionInput!): UpdateInstitutionPayload! @authorize(apply: BEFORE_RESOLVER, policy: "Write")
}

type Numeration {
  mainNumber: String!
  prefix: String
  suffix: String
}

type OpenEndedDateTimeRange {
  from: DateTime
  to: DateTime
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type PersonalUserDataError {
  code: PersonalUserDataErrorCode!
  message: String!
  path: [String!]!
}

type PersonalUserDataPayload {
  errors: [PersonalUserDataError!]
  user: User
}

type Publication implements Reference {
  abstract: String
  "arXiv.org is a free and open-access archive for publications. The arXiv identifier can be used to define a publication."
  arXiv: String
  authors: [String!]
  "The Digital Object Identifier (DOI) is a very important persistent identifier for publications. It MUST be defined here if it is available for a publication."
  doi: String
  "Referenced section"
  section: String
  title: String
  "A Uniform Resource Name (URN) can be used to define a publication. TODO: Improve the regex pattern to further restrict the string."
  urn: String
  "If a persistent identifiert like DOI is defined above, this webAdress can define a convenient web address to access the publication. However, if no persistent identifier exist, this web address is the only identifier of this publication. In this case, it is important to choose a web address with a high probability to persist long."
  webAddress: Url
}

type Query {
  component(uuid: Uuid!): Component
  components(after: String before: String first: Int last: Int order: [ComponentSortInput!] where: ComponentFilterInput): ComponentConnection @authorize(apply: BEFORE_RESOLVER, policy: "Read")
  currentUser: User
  database(uuid: Uuid!): Database
  databases(after: String before: String first: Int last: Int order: [DatabaseSortInput!] where: DatabaseFilterInput): DatabaseConnection @authorize(apply: BEFORE_RESOLVER, policy: "Read")
  dataFormat(uuid: Uuid!): DataFormat
  dataFormats(after: String before: String first: Int last: Int order: [DataFormatSortInput!] where: DataFormatFilterInput): DataFormatConnection @authorize(apply: BEFORE_RESOLVER, policy: "Read")
  institution(uuid: Uuid!): Institution
  institutions(after: String before: String first: Int last: Int order: [InstitutionSortInput!] where: InstitutionFilterInput): InstitutionConnection @authorize(apply: BEFORE_RESOLVER, policy: "Read")
  method(uuid: Uuid!): Method
  methods(after: String before: String first: Int last: Int order: [MethodSortInput!] where: MethodFilterInput): MethodConnection @authorize(apply: BEFORE_RESOLVER, policy: "Read")
  node(id: ID!): Node
  personalUserData: PersonalUserDataPayload! @authorize(apply: BEFORE_RESOLVER)
  users(after: String before: String first: Int last: Int order: [UserSortInput!]): UserConnection @authorize(apply: BEFORE_RESOLVER, policy: "Read")
}

type RegisterUserError {
  code: RegisterUserErrorCode!
  message: String!
  path: [String!]!
}

type RegisterUserPayload {
  errors: [RegisterUserError!]
  user: User
}

type RemoveInstitutionRepresentativeError {
  code: RemoveInstitutionRepresentativeErrorCode!
  message: String!
  path: [String!]!
}

type RemoveInstitutionRepresentativePayload {
  errors: [RemoveInstitutionRepresentativeError!]
  institution: Institution!
  user: User!
}

type RepresentedInstitutionEdge {
  node: Institution!
  role: InstitutionRepresentativeRole!
}

type RequestUserPasswordResetError {
  code: RequestUserPasswordResetErrorCode!
  message: String!
  path: [String!]!
}

type RequestUserPasswordResetPayload {
  errors: [RequestUserPasswordResetError!]
}

type ResendUserEmailConfirmationError {
  code: ResendUserEmailConfirmationErrorCode!
  message: String!
  path: [String!]!
}

type ResendUserEmailConfirmationPayload {
  errors: [ResendUserEmailConfirmationError!]
}

type ResendUserEmailVerificationError {
  code: ResendUserEmailVerificationErrorCode!
  message: String!
  path: [String!]!
}

type ResendUserEmailVerificationPayload {
  errors: [ResendUserEmailVerificationError!]
  user: User
}

type ResetUserPasswordError {
  code: ResetUserPasswordErrorCode!
  message: String!
  path: [String!]!
}

type ResetUserPasswordPayload {
  errors: [ResetUserPasswordError!]
}

type SetUserPasswordError {
  code: SetUserPasswordErrorCode!
  message: String!
  path: [String!]!
}

type SetUserPasswordPayload {
  errors: [SetUserPasswordError!]
  user: User
}

type SetUserPhoneNumberError {
  code: SetUserPhoneNumberErrorCode!
  message: String!
  path: [String!]!
}

type SetUserPhoneNumberPayload {
  errors: [SetUserPhoneNumberError!]
  user: User
}

"`ISO 52022` is an example of the abbreviation of a standardizer and the main number of the identifier."
type Standard implements Reference {
  abstract: String
  locator: Url
  numeration: Numeration!
  "The section of the standard to which the reference refers to."
  section: String
  standardizers: [Standardizer!]!
  title: String!
  "It is important to define the year in which the standard was issued because there can be relevant updates of one standard."
  year: Int
}

type UpdateInstitutionError {
  code: UpdateInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type UpdateInstitutionPayload {
  errors: [UpdateInstitutionError!]
  institution: Institution
}

type User implements Node & Stakeholder {
  developedMethods: UserDevelopedMethodConnection!
  email: String
  id: ID!
  "Full name"
  name: String!
  phoneNumber: String
  representedInstitutions: UserRepresentedInstitutionConnection!
  uuid: Uuid!
  websiteLocator: Url
}

"A connection to a list of items."
type UserConnection {
  "A list of edges."
  edges: [UserEdge!]
  "A flattened list of the nodes."
  nodes: [User!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserDevelopedMethodConnection {
  edges: [UserDevelopedMethodEdge!]!
}

type UserDevelopedMethodEdge {
  node: Method!
}

"An edge in a connection."
type UserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: User!
}

type UserRepresentedInstitutionConnection {
  edges: [UserRepresentedInstitutionEdge!]!
}

type UserRepresentedInstitutionEdge {
  node: Institution!
}

input AddInstitutionRepresentativeInput {
  institutionId: Uuid!
  role: InstitutionRepresentativeRole!
  userId: Uuid!
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input ChangeInstitutionRepresentativeRoleInput {
  institutionId: Uuid!
  newRole: InstitutionRepresentativeRole!
  userId: Uuid!
}

input ChangeUserEmailInput {
  newEmail: String!
}

input ChangeUserPasswordInput {
  currentPassword: String!
  newPassword: String!
  newPasswordConfirmation: String!
}

input ComparableGuidOperationFilterInput {
  eq: Uuid
  gt: Uuid
  gte: Uuid
  in: [Uuid!]
  lt: Uuid
  lte: Uuid
  neq: Uuid
  ngt: Uuid
  ngte: Uuid
  nin: [Uuid!]
  nlt: Uuid
  nlte: Uuid
}

input ComparableInt32OperationFilterInput {
  eq: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  neq: Int
  ngt: Int
  ngte: Int
  nin: [Int!]
  nlt: Int
  nlte: Int
}

input ComponentCategoryOperationFilterInput {
  eq: ComponentCategory
  in: [ComponentCategory!]
  neq: ComponentCategory
  nin: [ComponentCategory!]
}

input ComponentFilterInput {
  abbreviation: StringOperationFilterInput
  and: [ComponentFilterInput!]
  categories: ListComponentCategoryOperationFilterInput
  description: StringOperationFilterInput
  id: ComparableGuidOperationFilterInput
  name: StringOperationFilterInput
  or: [ComponentFilterInput!]
}

input ComponentSortInput {
  abbreviation: SortEnumType
  availability: SortEnumType
  description: SortEnumType
  id: SortEnumType
  name: SortEnumType
  xmin: SortEnumType
}

input ConfirmUserEmailChangeInput {
  confirmationCode: String!
  currentEmail: String!
  newEmail: String!
}

input ConfirmUserEmailInput {
  confirmationCode: String!
  email: String!
}

input CreateComponentInput {
  abbreviation: String
  availability: OpenEndedDateTimeRangeInput
  categories: [ComponentCategory!]!
  description: String!
  manufacturerId: Uuid!
  name: String!
}

input CreateDataFormatInput {
  description: String!
  extension: String
  mediaType: String!
  name: String!
  publication: CreatePublicationInput
  schemaLocator: Url
  standard: CreateStandardInput
}

input CreateDatabaseInput {
  description: String!
  locator: Url!
  name: String!
  operatorId: Uuid!
}

input CreateInstitutionInput {
  abbreviation: String
  description: String!
  name: String!
  ownerIds: [Uuid!]!
  publicKey: String
  state: InstitutionState!
  websiteLocator: Url
}

input CreateMethodInput {
  availability: OpenEndedDateTimeRangeInput
  calculationLocator: Url
  categories: [MethodCategory!]!
  description: String!
  name: String!
  publication: CreatePublicationInput
  standard: CreateStandardInput
  validity: OpenEndedDateTimeRangeInput
}

input CreateNumerationInput {
  mainNumber: String!
  prefix: String
  suffix: String
}

input CreatePublicationInput {
  abstract: String
  arXiv: String
  authors: [String!]
  doi: String
  section: String
  title: String
  urn: String
  webAddress: Url
}

input CreateStandardInput {
  abstract: String
  locator: Url
  numeration: CreateNumerationInput!
  section: String
  standardizers: [Standardizer!]!
  title: String
  year: Int
}

input DataFormatFilterInput {
  and: [DataFormatFilterInput!]
  description: StringOperationFilterInput
  id: ComparableGuidOperationFilterInput
  mediaType: StringOperationFilterInput
  name: StringOperationFilterInput
  or: [DataFormatFilterInput!]
}

input DataFormatSortInput {
  description: SortEnumType
  extension: SortEnumType
  id: SortEnumType
  manager: InstitutionSortInput
  managerId: SortEnumType
  mediaType: SortEnumType
  name: SortEnumType
  publication: PublicationSortInput
  reference: IReferenceSortInput
  schemaLocator: UriSortInput
  standard: StandardSortInput
  xmin: SortEnumType
}

input DatabaseFilterInput {
  and: [DatabaseFilterInput!]
  description: StringOperationFilterInput
  id: ComparableGuidOperationFilterInput
  locator: UriFilterInput
  name: StringOperationFilterInput
  or: [DatabaseFilterInput!]
}

input DatabaseSortInput {
  description: SortEnumType
  id: SortEnumType
  locator: UriSortInput
  name: SortEnumType
  operator: InstitutionSortInput
  operatorId: SortEnumType
  xmin: SortEnumType
}

input DeleteInstitutionInput {
  institutionId: Uuid!
}

input DeletePersonalUserDataInput {
  password: String
}

input IReferenceSortInput {
  abstract: SortEnumType
  section: SortEnumType
  title: SortEnumType
}

input InstitutionFilterInput {
  abbreviation: StringOperationFilterInput
  and: [InstitutionFilterInput!]
  description: StringOperationFilterInput
  id: ComparableGuidOperationFilterInput
  name: StringOperationFilterInput
  or: [InstitutionFilterInput!]
  websiteLocator: UriFilterInput
}

input InstitutionSortInput {
  abbreviation: SortEnumType
  description: SortEnumType
  id: SortEnumType
  name: SortEnumType
  publicKey: SortEnumType
  state: SortEnumType
  websiteLocator: UriSortInput
  xmin: SortEnumType
}

input ListComponentCategoryOperationFilterInput {
  all: ComponentCategoryOperationFilterInput
  any: Boolean
  none: ComponentCategoryOperationFilterInput
  some: ComponentCategoryOperationFilterInput
}

input ListMethodCategoryOperationFilterInput {
  all: MethodCategoryOperationFilterInput
  any: Boolean
  none: MethodCategoryOperationFilterInput
  some: MethodCategoryOperationFilterInput
}

input ListStringOperationFilterInput {
  all: StringOperationFilterInput
  any: Boolean
  none: StringOperationFilterInput
  some: StringOperationFilterInput
}

input LoginUserInput {
  email: String!
  password: String!
}

input MethodCategoryOperationFilterInput {
  eq: MethodCategory
  in: [MethodCategory!]
  neq: MethodCategory
  nin: [MethodCategory!]
}

input MethodFilterInput {
  and: [MethodFilterInput!]
  categories: ListMethodCategoryOperationFilterInput
  description: StringOperationFilterInput
  id: ComparableGuidOperationFilterInput
  name: StringOperationFilterInput
  or: [MethodFilterInput!]
}

input MethodSortInput {
  availability: SortEnumType
  calculationLocator: UriSortInput
  description: SortEnumType
  id: SortEnumType
  name: SortEnumType
  publication: PublicationSortInput
  reference: IReferenceSortInput
  standard: StandardSortInput
  validity: SortEnumType
  xmin: SortEnumType
}

input NumerationSortInput {
  mainNumber: SortEnumType
  prefix: SortEnumType
  suffix: SortEnumType
}

input OpenEndedDateTimeRangeInput {
  from: DateTime
  to: DateTime
}

input PublicationSortInput {
  abstract: SortEnumType
  "arXiv.org is a free and open-access archive for publications. The arXiv identifier can be used to define a publication."
  arXiv: SortEnumType
  "The Digital Object Identifier (DOI) is a very important persistent identifier for publications. It MUST be defined here if it is available for a publication."
  doi: SortEnumType
  "Referenced section"
  section: SortEnumType
  title: SortEnumType
  "A Uniform Resource Name (URN) can be used to define a publication. TODO: Improve the regex pattern to further restrict the string."
  urn: SortEnumType
  "If a persistent identifiert like DOI is defined above, this webAdress can define a convenient web address to access the publication. However, if no persistent identifier exist, this web address is the only identifier of this publication. In this case, it is important to choose a web address with a high probability to persist long."
  webAddress: UriSortInput
}

input RegisterUserInput {
  email: String!
  name: String!
  password: String!
  passwordConfirmation: String!
}

input RemoveInstitutionRepresentativeInput {
  institutionId: Uuid!
  userId: Uuid!
}

input RequestUserPasswordResetInput {
  email: String!
}

input ResendUserEmailConfirmationInput {
  email: String!
}

input ResetUserPasswordInput {
  email: String!
  password: String!
  passwordConfirmation: String!
  resetCode: String!
}

input SetUserPasswordInput {
  password: String!
  passwordConfirmation: String!
}

input SetUserPhoneNumberInput {
  phoneNumber: String!
}

"`ISO 52022` is an example of the abbreviation of a standardizer and the main number of the identifier."
input StandardSortInput {
  abstract: SortEnumType
  locator: UriSortInput
  numeration: NumerationSortInput
  "The section of the standard to which the reference refers to."
  section: SortEnumType
  title: SortEnumType
  "It is important to define the year in which the standard was issued because there can be relevant updates of one standard."
  year: SortEnumType
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  contains: String
  endsWith: String
  eq: String
  in: [String]
  ncontains: String
  nendsWith: String
  neq: String
  nin: [String]
  nstartsWith: String
  or: [StringOperationFilterInput!]
  startsWith: String
}

input UpdateInstitutionInput {
  abbreviation: String
  description: String!
  institutionId: Uuid!
  name: String!
  publicKey: String
  state: InstitutionState!
  websiteLocator: Url
}

input UriFilterInput {
  absolutePath: StringOperationFilterInput
  absoluteUri: StringOperationFilterInput
  and: [UriFilterInput!]
  authority: StringOperationFilterInput
  dnsSafeHost: StringOperationFilterInput
  fragment: StringOperationFilterInput
  host: StringOperationFilterInput
  hostNameType: UriHostNameTypeOperationFilterInput
  idnHost: StringOperationFilterInput
  isAbsoluteUri: BooleanOperationFilterInput
  isDefaultPort: BooleanOperationFilterInput
  isFile: BooleanOperationFilterInput
  isLoopback: BooleanOperationFilterInput
  isUnc: BooleanOperationFilterInput
  localPath: StringOperationFilterInput
  or: [UriFilterInput!]
  originalString: StringOperationFilterInput
  pathAndQuery: StringOperationFilterInput
  port: ComparableInt32OperationFilterInput
  query: StringOperationFilterInput
  scheme: StringOperationFilterInput
  segments: ListStringOperationFilterInput
  userEscaped: BooleanOperationFilterInput
  userInfo: StringOperationFilterInput
}

input UriHostNameTypeOperationFilterInput {
  eq: UriHostNameType
  in: [UriHostNameType!]
  neq: UriHostNameType
  nin: [UriHostNameType!]
}

input UriSortInput {
  absolutePath: SortEnumType
  absoluteUri: SortEnumType
  authority: SortEnumType
  dnsSafeHost: SortEnumType
  fragment: SortEnumType
  host: SortEnumType
  hostNameType: SortEnumType
  idnHost: SortEnumType
  isAbsoluteUri: SortEnumType
  isDefaultPort: SortEnumType
  isFile: SortEnumType
  isLoopback: SortEnumType
  isUnc: SortEnumType
  localPath: SortEnumType
  originalString: SortEnumType
  pathAndQuery: SortEnumType
  port: SortEnumType
  query: SortEnumType
  scheme: SortEnumType
  userEscaped: SortEnumType
  userInfo: SortEnumType
}

input UserSortInput {
  accessFailedCount: SortEnumType
  concurrencyStamp: SortEnumType
  email: SortEnumType
  emailConfirmed: SortEnumType
  id: SortEnumType
  lockoutEnabled: SortEnumType
  lockoutEnd: SortEnumType
  "Full name"
  name: SortEnumType
  normalizedEmail: SortEnumType
  normalizedUserName: SortEnumType
  passwordHash: SortEnumType
  phoneNumber: SortEnumType
  phoneNumberConfirmed: SortEnumType
  postalAddress: SortEnumType
  securityStamp: SortEnumType
  twoFactorEnabled: SortEnumType
  userName: SortEnumType
  websiteLocator: UriSortInput
  xmin: SortEnumType
}

enum AddInstitutionRepresentativeErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNKNOWN_USER
  DUPLICATE
  UNAUTHORIZED
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

enum ChangeInstitutionRepresentativeRoleErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNKNOWN_USER
  UNAUTHORIZED
  UNKNOWN_REPRESENTATIVE
  LAST_OWNER
}

enum ChangeUserEmailErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNCHANGED_EMAIL
  INVALID_EMAIL
}

enum ChangeUserPasswordErrorCode {
  UNKNOWN
  UNKNOWN_USER
  NO_PASSWORD
  PASSWORD_CONFIRMATION_MISMATCH
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
}

enum ComponentCategory {
  MATERIAL
  LAYER
  UNIT
}

enum ConfirmUserEmailChangeErrorCode {
  UNKNOWN
  DUPLICATE_EMAIL
  INVALID_CONFIRMATION_CODE
  UNKNOWN_USER
}

enum ConfirmUserEmailErrorCode {
  UNKNOWN
  UNKNOWN_USER
  INVALID_CONFIRMATION_CODE
}

enum CreateComponentErrorCode {
  UNKNOWN
  UNKNOWN_MANUFACTURER
  UNAUTHORIZED
}

enum CreateDataFormatErrorCode {
  UNKNOWN
  TWO_REFERENCES
}

enum CreateDatabaseErrorCode {
  UNKNOWN
  UNAUTHORIZED
  UNKNOWN_OPERATOR
}

enum CreateInstitutionErrorCode {
  UNKNOWN
  NO_OWNER
  UNKNOWN_OWNERS
}

enum CreateMethodErrorCode {
  UNKNOWN
  TWO_REFERENCES
}

enum DeleteInstitutionErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
}

enum DeletePersonalUserDataErrorCode {
  UNKNOWN
  UNKNOWN_USER
  MISSING_PASSWORD
  INCORRECT_PASSWORD
}

enum GenerateUserTwoFactorRecoveryCodesErrorCode {
  UNKNOWN
  UNKNOWN_USER
  TWO_FACTOR_AUTHENTICATION_DISABLED
}

enum InstitutionRepresentativeRole {
  OWNER
  MAINTAINER
  ASSISTANT
}

enum InstitutionState {
  UNKNOWN
  OPERATIVE
  INOPERATIVE
}

enum LoginUserErrorCode {
  INVALID
  LOCKED_OUT
  NOT_ALLOWED
  UNKNOWN
}

enum LogoutUserErrorCode {
  UNKNOWN
}

enum MethodCategory {
  MEASUREMENT
  CALCULATION
}

enum PersonalUserDataErrorCode {
  UNKNOWN
  UNKNOWN_USER
}

enum RegisterUserErrorCode {
  UNKNOWN
  PASSWORD_CONFIRMATION_MISMATCH
  DUPLICATE_EMAIL
  INVALID_EMAIL
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
  NULL_OR_EMPTY_EMAIL
}

enum RemoveInstitutionRepresentativeErrorCode {
  UNKNOWN
  LAST_OWNER
  UNAUTHORIZED
  UNKNOWN_INSTITUTION
  UNKNOWN_REPRESENTATIVE
  UNKNOWN_USER
}

enum RequestUserPasswordResetErrorCode {
  UNKNOWN
}

enum ResendUserEmailConfirmationErrorCode {
  UNKNOWN
}

enum ResendUserEmailVerificationErrorCode {
  UNKNOWN
  UNKNOWN_USER
}

enum ResetUserPasswordErrorCode {
  UNKNOWN
  INVALID_RESET_CODE
  PASSWORD_CONFIRMATION_MISMATCH
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
}

enum SetUserPasswordErrorCode {
  UNKNOWN
  UNKNOWN_USER
  EXISTING_PASSWORD
  PASSWORD_CONFIRMATION_MISMATCH
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
}

enum SetUserPhoneNumberErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNCHANGED_PHONE_NUMBER
}

enum SortEnumType {
  ASC
  DESC
}

enum Standardizer {
  AERC
  AGI
  ASHRAE
  BREEAM
  BS
  BSI
  CEN
  CIE
  DGNB
  DIN
  DVWG
  IEC
  IES
  IFT
  ISO
  JIS
  LEED
  NFRC
  RIBA
  UL
  UNECE
  VDI
  VFF
  WELL
}

enum UpdateInstitutionErrorCode {
  UNKNOWN
  UNAUTHORIZED
  UNKNOWN_INSTITUTION
}

enum UriHostNameType {
  UNKNOWN
  BASIC
  DNS
  I_PV4
  I_PV6
}

directive @authorize("Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field." apply: ApplyPolicy! = BEFORE_RESOLVER "The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!]) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer("Deferred when true." if: Boolean "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to." label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL service’s schema,such as deprecated fields on a type or deprecated enum values."
directive @deprecated("Deprecations include a reason for why it is deprecated, which is formatted using Markdown syntax (as specified by CommonMark)." reason: String = "No longer supported") on FIELD_DEFINITION | ENUM_VALUE

"Directs the executor to include this field or fragment only when the `if` argument is true."
directive @include("Included when true." if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Directs the executor to skip this field or fragment when the `if` argument is true."
directive @skip("Skipped when true." if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream("Streamed when true." if: Boolean! "The initial elements that shall be send down to the consumer." initialCount: Int! "If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to." label: String) on FIELD

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `UInt` scalar represents a 32-bit unsigned integer type."
scalar UInt

scalar Url

scalar Uuid
